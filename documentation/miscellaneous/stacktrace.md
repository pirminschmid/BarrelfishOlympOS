# Symbolic stack trace
While I write *error free code*<sup>(TM)</sup> in general, of course, once a freshly written part of the system had a bug that triggered the exception handler and stopped the system. Of course, this happened the night before the presentation of the next milestone in the morning. Finally, it could be fixed after a very nice group effort of debugging. But we realized that debugging a system is very cumbersome when only the program counter of the failing instruction was reported. We had to compare this address with the address in the objdump of the binary to find the location of the code. And of course, we could also use ```printf()``` to additionally print status information.

To simplify such debugging efforts, I decided to implement a stack trace routine that was called by exception handler if it (or our extensions) could not resolve the exception, e.g. page faults while already handling a page fault.

```C
//--- Stack trace ----------------------------------------------------------------------------------
// The stack trace is generated by following the frame pointers fp (r11) as indicated in the
// ARMv7 ABI.
// fp[-0] saved pc: hold the pc when this frame was created -> used to find the function base address
//                  the function label is 4 words (= 16 bytes) before -> adjustment
// fp[-1] saved lr: holds the return address for the function, which is one word after the
//        calling site. Thus, adjustment by one word again to get the proper call instruction.
// fp[-2] saved sp: not used at the moment
// fp[-3] saved fp: holds the fp of the calling function. It is NULL if the end of the call stack
// is reached.
//
// reference: stackoverflow answer by artless noise and edited by Pod on
// https://stackoverflow.com/questions/15752188/arm-link-register-and-frame-pointer?answertab=votes#tab-top
//
// Two interfaces are offered:
// - with (arch_registers_state_t *), typically called from an exception handler
// - starting from current program counter (pc), typically used for other debugging activities
//
// Three termination options are used:
// - clear end of stack trace (return address == NULL)
// - for known stack sizes (if thread_self() != NULL): in case detected fp would go outside
//   of known stack
// - for unknown stack size: if an arbitrary recursion depth is reached
//
// As an option, the debug symbols can be read from the ELF file and be used for symbol
// printing during the stacktrace
//
// version 2017-11-03 pisch

// note: this value can be changed as desired
#define DEBUG_STACK_TRACE_MAX_DEPTH_WITH_UNKNOWN_STACK 20

static void debug_stack_unwind(struct paging_elf_key_data *elf_info, uintptr_t **frame_ptr, uintptr_t *stack, uintptr_t *stack_top, int count)
{
    uintptr_t *return_addr = *(frame_ptr - 1);
    if (!return_addr) {
        return;
    }

    uintptr_t *pc = return_addr - 1;
    uintptr_t **prior_fp = (uintptr_t **)*(frame_ptr - 3);
    uintptr_t *function = prior_fp ? (*(prior_fp) - 4) : NULL;

    if (stack && stack_top) {
        if ((uintptr_t **)stack < prior_fp && prior_fp < (uintptr_t **)stack_top) {
            debug_stack_unwind(elf_info, prior_fp, stack, stack_top, count + 1);
        }
    }
    else {
        if (count < DEBUG_STACK_TRACE_MAX_DEPTH_WITH_UNKNOWN_STACK) {
            debug_stack_unwind(elf_info, prior_fp, stack, stack_top, count + 1);
        }
        else {
            debug_printf("<max. stack depth reached for unknown stack size (thread_self() == NULL)>\n");
        }
    }

    const char *function_name = find_function_name(elf_info, function);

    if (function_name) {
        debug_printf("- in function '%s' (%p) at %p\n", function_name, function, pc);
    }
    else {
        debug_printf("- in function <name unavailable> (%p) at %p\n", function, pc);
    }
}


static void debug_stack_trace_helper(uintptr_t **frame_ptr, uintptr_t *pc, const char *title, const char *message)
{
    struct paging_state *st = get_current_paging_state();
    assert(st);
    struct paging_elf_key_data *elf_info = &st->elf_info;

    uintptr_t **prior_fp = (uintptr_t **)*(frame_ptr - 3);

    debug_printf("\n");
    debug_printf("%s -- stack trace:\n", title);

    struct thread *self = thread_self();
    if (self) {
        debug_stack_unwind(elf_info, prior_fp, self->stack, self->stack_top, 0);
    }
    else {
        debug_stack_unwind(elf_info, prior_fp, NULL, NULL, 0);
    }

    uintptr_t *function = *(frame_ptr) - 4;

    const char *function_name = find_function_name(elf_info, function);

    if (function_name) {
        debug_printf("- %s in function '%s' (%p) at %p\n", message, function_name, function, pc);
    }
    else {
        debug_printf("- %s in function <name unavailable> (%p) at %p\n", message, function, pc);
    }
    debug_printf("\n");
}

void debug_stack_trace(arch_registers_state_t *regs, const char *title, const char *message)
{
    assert(regs);
    assert(title);
    assert(message);

    debug_stack_trace_helper((uintptr_t **)regs->named.r11, (uintptr_t *)regs->named.pc, title, message);
}

void debug_stack_trace_from_pc(uintptr_t **frame_ptr, uintptr_t *pc, const char *title)
{
    assert(frame_ptr);
    assert(pc);
    assert(title);
    debug_stack_trace_helper(frame_ptr, pc, title, "current location");
}

```

For additional convenience, a macro was defined in the header file that allowed printing this information from any location.

```C
//--- Stack trace ----------------------------------------------------------------------------------
// note: these functions are architecture specific and only implemented for ARM at the moment

void debug_stack_trace(arch_registers_state_t *regs, const char *title, const char *message);

void debug_stack_trace_from_pc(uintptr_t **frame_ptr, uintptr_t *pc, const char *title);

#define DEBUG_STACK_TRACE_FROM_HERE(title) do {                                       \
    uintptr_t *debug_pc;                                                              \
    __asm("mov %[debug_pc], r15" : [debug_pc] "=r" (debug_pc));                       \
    uintptr_t **debug_frame_ptr;                                                      \
    __asm("mov %[debug_frame_ptr], r11" : [debug_frame_ptr] "=r" (debug_frame_ptr));  \
    debug_stack_trace_from_pc(debug_frame_ptr, debug_pc, (title));                    \
} while(false)
```

But why stop there?

Additionally, the function symbol tables were loaded from the ELF binary file (normally not loaded) and used for function name resolution during runtime. For this, our domain spawn part was extended, and lookup functions from the provided ELF library a bit extended and modified. Finally, the error output during such exceptions reported the entire call stack with function names looking similar to such error traces from Java or debuggers.

```C
static struct Elf32_Sym *debug_elf32_find_function_symbol_by_addr(void *symtab_base, size_t symtab_size,
                                                  lvaddr_t addr, uintptr_t *sindex)
{
    assert(symtab_base);

    uintptr_t idx = 0;
    if (sindex) {
        if (0 < *sindex) {
            // does still point to found symbol if last search has been a success
            idx = *sindex + 1;
        }
    }

    uintptr_t symbase = (uintptr_t)symtab_base;

    struct Elf32_Sym *sym = NULL;

    // assure that the last part of the buffer is an entire struct
    uintptr_t max = (symtab_size / sizeof(struct Elf32_Sym)) * (sizeof(struct Elf32_Sym));

    // kept the uintptr_t implementation of the original; array access could be used as an alternative
    for (uintptr_t i = idx * sizeof(struct Elf32_Sym); i < max; i += sizeof(struct Elf32_Sym)) {
        // getting the symbol
        struct Elf32_Sym *test_sym = (struct Elf32_Sym *)(symbase + i);

        /* XXX: not handling relocatable symbols */
        // TODO pisch: this is the same state as the original elf32 function
        //             we adjust it here when we adjust it there.
        if (test_sym->st_value == addr) {
            sym = test_sym;
            break;
        }

        // test 2nd function prologue in parallel
        if (test_sym->st_value == (addr + 4)) {
            sym = test_sym;
            break;
        }

        idx++;
    }

    // it points to the end of the list if search has been unsuccessful
    if (sindex) {
        *sindex = idx;
    }

    return sym;
}


/**
 * Note: the proper .strtab must be provided that matches the .symtab
 * see struct Elf32_Shdr *strtab = shead+symtab->sh_link of the original
 * This is provided during the spawn process when the additional tables are loaded.
 */
static const char *debug_elf32_get_symbolname(void *strtab_base, size_t strtab_size, struct Elf32_Sym *sym)
{
    assert(strtab_base);
    assert(sym);

    // get the pointer to the symbol name from string table + string index
    // assure that the requested name is not outside of allocated memory region
    const char *name = ((const char *)strtab_base) + sym->st_name;

    if ((uintptr_t)name >= ((uintptr_t)strtab_base + strtab_size)) {
        return NULL;
    }

    return name;
}

/**
 * uses ELF information to retrieve the symbol name of the function address, if available
 * \return may be NULL if not found or if symtab_base or strtab_base not available
 *
 * note: multiple symbols are stored per address, e.g. $a with name index 1, st_info = 0,
 * Function symbols have values 2 or 18. Thus filtering for the bit set by STT_FUNC (= 2)
 */
static const char *find_function_name(struct paging_elf_key_data *elf_info, uintptr_t *function)
{
    assert(elf_info);

    if(!elf_info->symtab_base) {
        return NULL;
    }

    if(!elf_info->strtab_base) {
        return NULL;
    }

    if (!function) {
        return NULL;
    }

    // currently, multiple symbols are stored per address
    // first a symbol $a is found with name index 1
    // then the actually desired function name symbol is found
    struct Elf32_Sym *sym = NULL;
    uintptr_t sindex = 0;
    do {
        sym = debug_elf32_find_function_symbol_by_addr((struct Elf32_Shdr *)elf_info->symtab_base, elf_info->symtab_size, (lvaddr_t)function, &sindex);
    } while ((sym) && !(sym->st_info & STT_FUNC));

    if (!sym) {
        return NULL;
    }

    return debug_elf32_get_symbolname((struct Elf32_Shdr *)elf_info->strtab_base, elf_info->strtab_size, sym);
}
```
